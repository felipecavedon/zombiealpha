<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Zombie Survival - A pixel art action survival game">
    <meta name="author" content="Cavedon">
    <title>Zombie Survival - Alpha v3.0</title>
    <style>
        /* =====================================================
           RESET & BASE STYLES
           ===================================================== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: monospace;
        }

        /* =====================================================
           GAME CANVAS
           ===================================================== */
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* =====================================================
           UI COMPONENTS
           ===================================================== */
        .ui-button {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #ffd54a;
            border-radius: 8px;
            padding: 10px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .ui-button:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #fff;
            transform: scale(1.05);
        }

        .ui-button:active {
            transform: scale(0.95);
        }

        #waveControl {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 100;
        }

        /* =====================================================
           SHOP INTERFACE
           ===================================================== */
        #shopInterface {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            border: 3px solid #fff;
            border-radius: 12px;
            padding: 20px;
            color: #fff;
            font-family: monospace;
            font-size: 14px;
            z-index: 200;
            display: none;
            min-width: 500px;
            text-align: center;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #shopInterface h2 {
            color: #fff;
            margin-bottom: 20px;
            font-size: 24px;
        }

        .shopItemsContainer {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .shopItem {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #555;
            border-radius: 8px;
            padding: 15px;
            margin: 10px 5px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: space-between;
            flex: 1;
            min-width: 180px;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .shopItem:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: #fff;
            transform: scale(1.02);
        }

        .shopItem.selected {
            border-color: #fff;
            background: rgba(255, 255, 255, 0.1);
        }

        .shopItem[disabled] {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .shopItemInfo {
            text-align: left;
        }

        .shopItemName {
            font-weight: bold;
            color: #fff;
            margin-bottom: 5px;
        }

        .shopItemStats {
            font-size: 12px;
            color: #ccc;
        }

        .shopControls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #555;
        }

        .shopButton {
            background: #fff;
            color: #000;
            border: none;
            border-radius: 6px;
            padding: 10px 20px;
            font-family: monospace;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.2s;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .shopButton:hover {
            background: #ccc;
            transform: scale(1.05);
        }

        .shopButton:disabled {
            background: #666;
            color: #999;
            cursor: not-allowed;
            transform: none;
        }

        /* =====================================================
           LOADING SCREEN
           ===================================================== */
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            color: #fff;
            font-size: 24px;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">Loading...</div>
    <canvas id="gameCanvas"></canvas>
    <button id="waveControl" class="ui-button">START WAVES</button>
    
    <!-- Shop Interface -->
    <div id="shopInterface">
        <h2>MERCHANT SHOP</h2>
        <div class="shopItemsContainer">
            <div id="shopItems"></div>
        </div>
        <div class="shopControls">
            <button id="buyButton" class="shopButton" disabled>SWAP WEAPON</button>
            <button id="closeShopButton" class="shopButton">CLOSE</button>
        </div>
    </div>
    
    <script>
    'use strict';

    // =====================================================
    // GAME CONFIGURATION
    // =====================================================
    const CONFIG = {
        // Version
        GAME_VERSION: '3.0.0-alpha',
        DEBUG_MODE: false,
        
        // Physics
        GRAVITY: 2000,
        BULLET_GRAVITY: 120,
        PLAYER_MOVE_SPEED: 160,
        PLAYER_JUMP_SPEED: 540,
        
        // World
        GROUND_HEIGHT: 40,
        GROUND_COLLISION_OFFSET: -6,
        
        // Visual
        SCREEN_SHAKE_DECAY: 40,
        CLOUD_SPEED: 0.04,
        CLOUD_SPACING: 600,
        CLOUD_PIXEL_SIZE: 40,
        
        // Player
        PLAYER_WIDTH: 30,
        PLAYER_HEIGHT: 40,
        PLAYER_MAX_HP: 100,
        PLAYER_START_X: 60,
        
        // Combat
        HEADSHOT_DAMAGE_MULTIPLIER: 2.5,
        HEADSHOT_ZONE_HEIGHT_RATIO: 0.15,
        
        // Timing
        WAVE_DELAY: 2000,
        RESTART_DELAY: 300,
        INITIAL_SETUP_DELAY: 50,
        LOADING_HIDE_DELAY: 100,
        ZOMBIE_SPAWN_DELAY: 1500,
        ZOMBIE_SPAWN_INITIAL_DELAY: 1000,
        
        // UI
        HP_BAR_WIDTH: 260,
        HP_BAR_HEIGHT: 16,
        WEAPON_SLOT_WIDTH: 110,
        WEAPON_SLOT_HEIGHT: 36,
        WEAPON_SLOT_PADDING: 6,
        
        // Merchant
        MERCHANT_X: 60,
        MERCHANT_INTERACTION_RANGE: 80
    };

    // =====================================================
    // COLOR PALETTE
    // =====================================================
    const PALETTE = {
        // UI Colors
        outline: '#1a1c2c',
        white: '#fff',
        black: '#000',
        
        // Character Colors
        skin: '#ffd37d',
        blue: '#2490ff',
        blueDark: '#0b4aa8',
        
        // Enemy Colors
        zombieFlesh: '#8b8b8b',
        zombieFleshDark: '#5a5a5a',
        zombieFleshLight: '#b0b0b0',
        
        // Environment Colors
        ground: '#27401f',
        groundHi: '#48a63f',
        bgNear: '#1d2230',
        bgFar: '#131822',
        cloudDark: '#131822',
        
        // Combat Colors
        red: '#e53935',
        hpHi: '#7CFC00',
        hpMid: '#ffb74d',
        hpLow: '#ef5350',
        bullet: '#ffe66d',
        bulletPellet: '#ffcc00',
        muzzleFlash: '#fff9c4',
        
        // Effect Colors
        acid: '#00ff00',
        headshot: '#ff0000',
        yellow: '#ffeb3b',
        wood: '#bc6a3c',
        gunMetal: '#2a2a2a'
    };

    // =====================================================
    // ASSET DATA
    // =====================================================
    const SPRITES = {
        player: {
            left: [
                "..OOOOOOOO..",".OssssssOOO.",".OssssssOOOO",
                ".OssssssOOOO",".OssssssOOOO",".OssssssbbbO",".OssssssbbbO",
                ".OssssssbbbO",".OssssssbbbO",".OssssssbbbO",".OssssssbbbO",
                ".ObbbbbbbbbO",".ObbbbbbbOO.","..OOOOOOOO.."
            ],
            right: null
        },
        zombie: {
            left: [
                "..OOOOOOOO..",".OggggggOOO.",".OggggggOOOO",
                ".OggggggOOOO",".OggggggOOOO",".OggggggGGGO",".OggggggGGGO",
                ".OggggggGGGO",".OggggggGGGO",".OggggggGGGO",".OggggggGGGO",
                ".OggggggGGGO",".OGGGGGGGOO.","..OOOOOOOO.."
            ],
            right: null
        },
        zombieFat: {
            left: [
                "..OOOOOOOO..",".OgggggggOO.",".OgggggggOO.",
                ".OgggggggOOO",".OgggggggOOO",".OgggggggOOO",".OgggggggGGG",
                ".OgggggggGGG",".OgggggggGGG",".OgggggggGGG",".OgggggggGGG",
                ".OgggggggGGG",".OGGGGGGGGGO","..OOOOOOOO.."
            ],
            right: null
        },
        zombieSpitter: {
            left: [
                "..OOOOOOOO..",".OggggggOOO.",".OggggggOOOO",
                ".OggggggOOOO",".OggggggOOOO",".OagggggGGGO",".OaaggggGGGO",
                ".OagggggGGGO",".OggggggGGGO",".OggggggGGGO",".OggggggGGGO",
                ".OggggggGGGO",".OGGGGGGGGGO","..OGGGGGGGGO","..OGGGGGGOO.",
                "...OOOOOOO.."
            ],
            right: null
        },
        zombieTank: {
            left: [
                "..OOOOOOOOOOOO..",".OgggggggggggOO.",".OgggggggggggOO.",
                ".OWWWWWWWWWWWOOO",".OWWWWWWWWWWWOOO",".OWWWWWWWWWWWOOO",
                ".OWWWWWWWWWWWGGG",".OWWWWWWWWWWWGGG",".OWWWWWWWWWWWGGG",
                ".OWWWWWWWWWWWGGG",".OWWWWWWWWWWWGGG",".OWWWWWWWWWWWGGG",
                ".OWWWWWWWWWWWGGG",".OGGGGGGGGGGGGGO","..OGGGGGGGGGGGGO",
                "..OGGGGGGGGGGOO.","...OOOOOOOOOOO.."
            ],
            right: null
        },
        zombieTankUnshielded: {
            left: [
                "..OOOOOOOOOOOO..",".OgggggggggggOO.",".OgggggggggggOO.",
                ".OgggggggggggOOO",".OgggggggggggOOO",".OgggggggggggOOO",
                ".OgggggggggggGGG",".OgggggggggggGGG",".OgggggggggggGGG",
                ".OgggggggggggGGG",".OgggggggggggGGG",".OgggggggggggGGG",
                ".OgggggggggggGGG",".OGGGGGGGGGGGGGO","..OGGGGGGGGGGGGO",
                "..OGGGGGGGGGGOO.","...OOOOOOOOOOO.."
            ],
            right: null
        },
        merchant: {
            left: [
                "..OOOOOOOO..",".OssssssOOO.",".OssssssOOOO",
                ".OssssssOOOO",".OssssssOOOO",".OssssssyyyO",".OssssssyyyO",
                ".OssssssyyyO",".OssssssyyyO",".OssssssyyyO",".OssssssyyyO",
                ".OyyyyyyyyyO",".OyyyyyyyOO.","..OOOOOOOO.."
            ],
            right: null
        },
        weapons: {
            assaultRifle: ["...b....","bbbbbbbb","bbb.b...","....b..."],
            pistol: [".bbbbb..","..bb....","..b....."],
            knife: ["....b...","....b...","...bbb..","....b..."],
            shotgun: ["bbbbbbbb","b..bbbb."],
            minigun: [".bb.........",".b..........",".bbb.b.b.bb.",".bbbbbbbbbb.",".bbb.b.b.bb."],
            sniperRifle: ["...bbb....","bbbbbbbbbb","bbb......."],
            smg: ["...b....",".bbbbbb.",".b..b...","....b..."]
        },
        effects: {
            blood: ["..r.....",".rrr...","..r....."],
            spark: ["..y.....",".yyy...","..y....."],
            headshot: ["r.r",".r.","r.r"],
            acid: [".a.","a.a",".a."],
            shieldBreak: [".w.","w.w",".w."]   
        }
    };

    const SPRITE_COLOR_MAP = {
        'O': 'outline',
        's': 'skin',
        'b': 'blue',
        'B': 'blueDark',
        'g': 'zombieFlesh',
        'G': 'zombieFleshDark',
        'r': 'red',
        'y': 'yellow',
        'l': 'bullet',
        'a': 'acid',
        'w': 'white',
        'W': 'wood'
    };

    const CLOUD_SPRITES = [
        ["..bb...",".bbbbb.","bbbbbbb","bbbbbbb",".bbbbb.","..bb..."],
        ["...bb..","..bbbb.","bbbbbbb","bbbbbbb","..bbbb.","...bb.."],
        ["..bbbb..",".bbbbbbb.","bbbbbbbbb","bbbbbbbbb",".bbbbbbb.","..bbbb.."],
        ["...bbbb...","..bbbbbbb..",".bbbbbbbbb.","bbbbbbbbbb",".bbbbbbbbb.","..bbbbbbb..","...bbbb..."],
        ["..bbbbbb..",".bbbbbbbbb.","bbbbbbbbbbb","bbbbbbbbbbb","bbbbbbbbbbb",".bbbbbbbbb.","..bbbbbb.."],
        ["...bbbbbb...","..bbbbbbbbb..",".bbbbbbbbbbb.","bbbbbbbbbbbb","bbbbbbbbbbbb",".bbbbbbbbbbb.","..bbbbbbbbb..","...bbbbbb..."],
        ["..b.bb..",".bbbbbb.","bbbbbbbb","bbbbbbbb",".bbbbbb.","..b.bb.."],
        ["...b.bb...","..bbbbbb..",".bbbbbbbb.","bbbbbbbbbb",".bbbbbbbb.","..bbbbbb..","...b.bb..."],
        ["....bb....","...bbbb...","..bbbbbb..",".bbbbbbbb.","..bbbbbb..","...bbbb...","....bb...."],
        [".....bb.....","....bbbb....","...bbbbbb...","..bbbbbbbb..","...bbbbbb...","....bbbb....",".....bb....."]
    ];

    // =====================================================
    // GAME DATA
    // =====================================================
    const WEAPONS = {
        rifle: {
            id: 'rifle_mk1',
            name: 'Assault Rifle',
            type: 'primary',
            damage: 7,
            fireRate: 10,
            bulletSpeed: 1100,
            recoilKick: 10,
            knockback: 140,
            flashTime: 0.05,
            effectiveRange: 800,
            accuracy: 0.95,
            sprite: 'assaultRifle',
            ammo: { current: 30, max: 30, reserve: Infinity, type: 'rifle_ammo' },
            reloadTime: 2.5
        },
        pistol: {
            id: 'pistol_basic',
            name: 'Pistol',
            type: 'secondary',
            damage: 5,
            fireRate: 4,
            bulletSpeed: 900,
            recoilKick: 6,
            knockback: 90,
            flashTime: 0.04,
            effectiveRange: 400,
            accuracy: 0.85,
            sprite: 'pistol',
            ammo: { current: 15, max: 15, reserve: Infinity, type: 'pistol_ammo' },
            reloadTime: 1.8
        },
        knife: {
            id: 'knife_mk1',
            name: 'Combat Knife',
            type: 'melee',
            damage: 15,
            range: 32,
            cooldown: 0.38,
            sprite: 'knife',
            ammo: { current: Infinity, max: Infinity, reserve: Infinity, type: 'melee_durability' },
            reloadTime: 0
        },
        shotgun: {
            id: 'shotgun_basic',
            name: 'Shotgun',
            type: 'primary',
            damage: 36,
            fireRate: 1.5,
            bulletSpeed: 700,
            recoilKick: 20,
            knockback: 250,
            flashTime: 0.1,
            effectiveRange: 250,
            accuracy: 0.65,
            sprite: 'shotgun',
            pelletCount: 6,
            spreadAngle: Math.PI * 0.15,
            ammo: { current: 8, max: 8, reserve: Infinity, type: 'shotgun_shells' },
            reloadTime: 3.2
        },
        smg: {
            id: 'smg_basic',
            name: 'SMG',
            type: 'primary',
            damage: 4,
            fireRate: 15,
            bulletSpeed: 950,
            recoilKick: 8,
            knockback: 80,
            flashTime: 0.03,
            effectiveRange: 350,
            accuracy: 0.75,
            sprite: 'smg',
            ammo: { current: 25, max: 25, reserve: Infinity, type: 'smg_ammo' },
            reloadTime: 1.8
        },
        sniper: {
            id: 'sniper_basic',
            name: 'Sniper Rifle',
            type: 'primary',
            damage: 50,
            fireRate: 1,
            bulletSpeed: 2500,
            recoilKick: 25,
            knockback: 300,
            flashTime: 0.08,
            effectiveRange: 1200,
            accuracy: 0.99,
            sprite: 'sniperRifle',
            ammo: { current: 5, max: 5, reserve: Infinity, type: 'sniper_ammo' },
            reloadTime: 3.5
        },
        minigun: {
            id: 'minigun_basic',
            name: 'Minigun',
            type: 'primary',
            damage: 6,
            fireRate: 20,
            bulletSpeed: 1000,
            recoilKick: 15,
            knockback: 120,
            flashTime: 0.02,
            effectiveRange: 600,
            accuracy: 0.70,
            sprite: 'minigun',
            ammo: { current: 100, max: 100, reserve: Infinity, type: 'minigun_ammo' },
            reloadTime: 4.0
        }
    };

    const SHOP_ITEMS = {
        shotgun: {
            id: 'shotgun_basic',
            name: 'Shotgun',
            type: 'primary',
            price: 0,
            weapon: { ...WEAPONS.shotgun },
            stats: `DMG: ${WEAPONS.shotgun.damage} | RATE: ${WEAPONS.shotgun.fireRate}/s | RANGE: ${WEAPONS.shotgun.effectiveRange}`
        },
        assaultRifle: {
            id: 'rifle_mk1',
            name: 'Assault Rifle',
            type: 'primary',
            price: 0,
            weapon: { ...WEAPONS.rifle },
            stats: `DMG: ${WEAPONS.rifle.damage} | RATE: ${WEAPONS.rifle.fireRate}/s | RANGE: ${WEAPONS.rifle.effectiveRange}`
        },
        smg: {
            id: 'smg_basic',
            name: 'SMG',
            type: 'primary',
            price: 0,
            weapon: { ...WEAPONS.smg },
            stats: `DMG: ${WEAPONS.smg.damage} | RATE: ${WEAPONS.smg.fireRate}/s | RANGE: ${WEAPONS.smg.effectiveRange}`
        },
        sniper: {
            id: 'sniper_basic',
            name: 'Sniper Rifle',
            type: 'primary',
            price: 0,
            weapon: { ...WEAPONS.sniper },
            stats: `DMG: ${WEAPONS.sniper.damage} | RATE: ${WEAPONS.sniper.fireRate}/s | RANGE: ${WEAPONS.sniper.effectiveRange}`
        },
        minigun: {
            id: 'minigun_basic',
            name: 'Minigun',
            type: 'primary',
            price: 0,
            weapon: { ...WEAPONS.minigun },
            stats: `DMG: ${WEAPONS.minigun.damage} | RATE: ${WEAPONS.minigun.fireRate}/s | RANGE: ${WEAPONS.minigun.effectiveRange}`
        }
    };

    const ENEMY_TYPES = {
        zombie: {
            width: 30,
            height: 40,
            speed: 55,
            touchDamage: 10,
            hitCooldown: 0.6,
            maxHP: 30,
            spriteKey: 'zombie'
        },
        zombieFat: {
            width: 42,
            height: 56,
            speed: 35,
            touchDamage: 15,
            hitCooldown: 0.8,
            maxHP: 80,
            spriteKey: 'zombieFat'
        },
        zombieSpitter: {
            width: 30,
            height: 40,
            speed: 40,
            touchDamage: 5,
            hitCooldown: 1.0,
            maxHP: 45,
            spriteKey: 'zombieSpitter',
            attackRange: 400,
            attackCooldown: 2.0,
            projectileSpeed: 120,
            projectileDamage: 12
        },
        zombieTank: {
            width: 48,
            height: 64,
            speed: 25,
            touchDamage: 20,
            hitCooldown: 1.2,
            maxHP: 120,
            shieldHP: 80,
            maxShieldHP: 80,
            spriteKey: 'zombieTank'
        }
    };

    const WAVE_ZOMBIE_TYPES = {
        1: ['zombie'],
        2: ['zombieFat', 'zombie'],
        3: ['zombieSpitter', 'zombie', 'zombieFat'],
        4: ['zombieTank', 'zombie', 'zombieFat', 'zombieSpitter'],
        5: ['zombie', 'zombieFat', 'zombieSpitter', 'zombieTank']
    };

    // =====================================================
    // UTILITY FUNCTIONS
    // =====================================================
    class Utils {
        static clamp(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }

        static flipSprite(sprite) {
            return sprite.map(row => row.split('').reverse().join(''));
        }

        static checkCollision(x1, y1, w1, h1, x2, y2, w2, h2) {
            return x1 < x2 + w2 && x1 + w1 > x2 && 
                   y1 < y2 + h2 && y1 + h1 > y2;
        }

        static checkEntityCollision(a, b) {
            return this.checkCollision(
                a.x, a.y, a.width, a.height,
                b.x, b.y, b.width, b.height
            );
        }

        static getGroundY(canvasHeight, entityHeight) {
            return canvasHeight - CONFIG.GROUND_HEIGHT - CONFIG.GROUND_COLLISION_OFFSET - entityHeight;
        }

        static rotateVector(dirX, dirY, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            return {
                x: dirX * cos - dirY * sin,
                y: dirX * sin + dirY * cos
            };
        }

        static normalizeVector(x, y) {
            const length = Math.hypot(x, y) || 1;
            return { x: x / length, y: y / length };
        }

        static getDirection(fromX, fromY, toX, toY) {
            const dx = toX - fromX;
            const dy = toY - fromY;
            return this.normalizeVector(dx, dy);
        }

        static getDistance(x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            return Math.sqrt(dx * dx + dy * dy);
        }

        static shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }
    }

    // =====================================================
    // AUDIO MANAGER
    // =====================================================
    class AudioManager {
        constructor() {
            this.audioContext = null;
            this.soundConfigs = {
                shot: { duration: 0.08, decay: 40, gain: 0.3 },
                melee: { duration: 0.12, decay: 25, gain: 0.4 },
                shotgun: { duration: 0.12, decay: 30, gain: 0.5 },
                empty: { duration: 0.06, decay: 150, gain: 0.3 }
            };
        }

        init() {
            if (!this.audioContext) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (AudioContext) {
                    this.audioContext = new AudioContext();
                }
            }
        }

        playSound(type) {
            if (!this.audioContext) return;

            const config = this.soundConfigs[type];
            if (!config) return;

            if (type === 'empty') {
                this.playEmptyClick(config);
            } else {
                this.playNoiseSound(config);
            }
        }

        playNoiseSound(config) {
            const buffer = this.createNoiseBuffer(config.duration, config.decay);
            this.playBuffer(buffer, config.gain);
        }

        playEmptyClick(config) {
            const buffer = this.createClickBuffer(config.duration, config.decay);
            this.playBuffer(buffer, config.gain);
        }

        createNoiseBuffer(duration, decay) {
            const sampleRate = this.audioContext.sampleRate;
            const samples = Math.floor(sampleRate * duration);
            const buffer = this.audioContext.createBuffer(1, samples, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                data[i] = (Math.random() * 2 - 1) * Math.exp(-decay * t);
            }

            return buffer;
        }

        createClickBuffer(duration, decay) {
            const sampleRate = this.audioContext.sampleRate;
            const samples = Math.floor(sampleRate * duration);
            const buffer = this.audioContext.createBuffer(1, samples, sampleRate);
            const data = buffer.getChannelData(0);

            for (let i = 0; i < samples; i++) {
                const t = i / sampleRate;
                
                if (t < 0.005) {
                    data[i] = (Math.random() - 0.5) * 0.6;
                } else if (t < 0.02) {
                    data[i] = (Math.random() - 0.5) * 0.2 * Math.exp(-decay * t);
                } else {
                    data[i] = (Math.random() - 0.5) * 0.1 * Math.exp(-100 * t);
                }
            }

            return buffer;
        }

        playBuffer(buffer, gain) {
            const source = this.audioContext.createBufferSource();
            source.buffer = buffer;

            const gainNode = this.audioContext.createGain();
            gainNode.gain.value = gain;

            source.connect(gainNode).connect(this.audioContext.destination);
            source.start();
        }
    }

    // =====================================================
    // INPUT MANAGER
    // =====================================================
    class InputManager {
        constructor(game) {
            this.game = game;
            this.keys = { w: false, a: false, d: false };
            this.mouse = { x: 0, y: 0, down: false };
            this.initEventListeners();
        }

        initEventListeners() {
            window.addEventListener('keydown', (e) => this.handleKeyDown(e));
            window.addEventListener('keyup', (e) => this.handleKeyUp(e));
            this.game.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            this.game.canvas.addEventListener('mousedown', () => this.handleMouseDown());
            window.addEventListener('mouseup', () => this.handleMouseUp());
        }

        handleKeyDown(e) {
            const key = e.key.toLowerCase();
            
            if (key in this.keys) {
                e.preventDefault();
                this.keys[key] = true;
            }

            const keyActions = {
                'w': () => this.handleJump(),
                '1': () => this.game.weaponSystem.switchSlot('primary'),
                '2': () => this.game.weaponSystem.switchSlot('secondary'),
                '3': () => this.game.weaponSystem.switchSlot('melee'),
                'r': () => this.handleReload(),
                'e': () => this.game.shopSystem.tryOpenShop(),
                ' ': () => this.handleRestart()
            };

            const action = keyActions[key];
            if (action) action();
        }

        handleKeyUp(e) {
            const key = e.key.toLowerCase();
            if (key in this.keys) {
                this.keys[key] = false;
            }
        }

        handleMouseMove(e) {
            const rect = this.game.canvas.getBoundingClientRect();
            this.mouse.x = e.clientX - rect.left;
            this.mouse.y = e.clientY - rect.top;
        }

        handleMouseDown() {
            if (!this.game.gameOver) {
                this.mouse.down = true;
                this.game.audioManager.init();
            }
        }

        handleMouseUp() {
            this.mouse.down = false;
            this.game.weaponSystem.resetWeaponStates();
        }

        handleJump() {
            const player = this.game.player;
            if (player.onGround && !this.game.gameOver) {
                player.velocityY = -CONFIG.PLAYER_JUMP_SPEED;
                player.onGround = false;
            }
        }

        handleReload() {
            if (!this.game.gameOver) {
                this.game.weaponSystem.reloadCurrentWeapon();
            }
        }

        handleRestart() {
            if (this.game.gameOver && this.game.canRestart) {
                this.game.restart();
            }
        }
    }

    // =====================================================
    // WEAPON SYSTEM
    // =====================================================
    class WeaponSystem {
        constructor(game) {
            this.game = game;
            this.currentSlot = 'primary';
            this.inventory = this.initializeInventory();
        }

        initializeInventory() {
            return {
                primary: this.createWeaponInstance(WEAPONS.rifle),
                secondary: this.createWeaponInstance(WEAPONS.pistol),
                melee: this.createWeaponInstance(WEAPONS.knife)
            };
        }

        createWeaponInstance(weaponTemplate) {
            return {
                ...weaponTemplate,
                lastShot: -999,
                lastSwing: -999,
                emptyClickPlayed: false,
                wasFiring: false,
                isReloading: false,
                reloadStartTime: null,
                reloadEndTime: null
            };
        }

        switchSlot(slot) {
            if (this.currentSlot !== slot) {
                this.cancelCurrentReload();
            }
            this.currentSlot = slot;
        }

        cancelCurrentReload() {
            const weapon = this.getCurrentWeapon();
            if (weapon?.isReloading) {
                weapon.isReloading = false;
                weapon.reloadStartTime = null;
                weapon.reloadEndTime = null;
            }
        }

        getCurrentWeapon() {
            return this.inventory[this.currentSlot];
        }

        update() {
            if (!this.game.inputManager.mouse.down) return;

            const weapon = this.getCurrentWeapon();
            if (weapon.type === 'melee') {
                this.tryMeleeAttack(weapon);
            } else {
                this.tryFireWeapon(weapon);
            }
        }

        tryFireWeapon(weapon) {
            if (!this.canFire(weapon)) return;

            if (this.isOutOfAmmo(weapon)) {
                this.handleEmptyWeapon(weapon);
                return;
            }
            
            this.fireWeapon(weapon);
        }

        canFire(weapon) {
            const now = this.game.timeElapsed;
            const cooldown = 1 / weapon.fireRate;
            return now - weapon.lastShot >= cooldown && !weapon.isReloading;
        }

        isOutOfAmmo(weapon) {
            return weapon.ammo && weapon.ammo.current <= 0;
        }

        handleEmptyWeapon(weapon) {
            if (!weapon.emptyClickPlayed && !weapon.wasFiring) {
                this.game.audioManager.playSound('empty');
                weapon.emptyClickPlayed = true;
            }
        }

        fireWeapon(weapon) {
            weapon.emptyClickPlayed = false;
            weapon.wasFiring = true;
            weapon.lastShot = this.game.timeElapsed;

            const gunPos = this.getGunPosition();
            const direction = this.calculateFireDirection(gunPos);

            if (weapon.id === 'shotgun_basic') {
                this.fireShotgun(gunPos, direction, weapon);
            } else {
                this.fireSingleBullet(gunPos, direction, weapon);
            }

            this.applyRecoil(direction, weapon);
            this.createMuzzleFlash(gunPos, direction, weapon);
            this.consumeAmmo(weapon);
            
            const soundType = weapon.id === 'shotgun_basic' ? 'shotgun' : 'shot';
            this.game.audioManager.playSound(soundType);
        }

        tryMeleeAttack(weapon) {
            const now = this.game.timeElapsed;
            if (now - weapon.lastSwing < weapon.cooldown) return;
            
            weapon.lastSwing = now;

            const hitBox = this.getMeleeHitBox(weapon);
            const hitAny = this.checkMeleeHits(hitBox, weapon);

            this.game.effectsManager.addScreenShake(hitAny ? 4 : 1.5);
            this.game.effectsManager.createMeleeSlash(this.getGunPosition(), this.game.player.facingRight);
            this.game.audioManager.playSound('melee');
        }

        fireShotgun(gunPos, direction, weapon) {
            const { pelletCount, spreadAngle, damage, bulletSpeed } = weapon;
            const pelletSpread = spreadAngle / (pelletCount - 1);
            const pelletDamage = Math.floor(damage / pelletCount);
            
            for (let i = 0; i < pelletCount; i++) {
                const angle = this.calculatePelletAngle(i, pelletCount, pelletSpread);
                const pelletDir = Utils.rotateVector(direction.x, direction.y, angle);
                const normalizedDir = Utils.normalizeVector(pelletDir.x, pelletDir.y);
                const speedVariation = 0.9 + Math.random() * 0.2;
                
                this.createBullet(gunPos, normalizedDir, bulletSpeed * speedVariation, pelletDamage, weapon, true);
            }
        }

        calculatePelletAngle(index, count, spread) {
            const baseAngle = (index - (count - 1) / 2) * spread;
            const randomSpread = (Math.random() - 0.5) * spread * 0.2;
            return baseAngle + randomSpread;
        }

        fireSingleBullet(gunPos, direction, weapon) {
            const finalDir = this.applyAccuracy(direction, weapon.accuracy);
            this.createBullet(gunPos, finalDir, weapon.bulletSpeed, weapon.damage, weapon, false);
        }

        applyAccuracy(direction, accuracy) {
            if (!accuracy || accuracy >= 1.0) return direction;
            
            const spreadAngle = (1.0 - accuracy) * Math.PI * 0.3;
            const randomAngle = (Math.random() - 0.5) * spreadAngle;
            const rotated = Utils.rotateVector(direction.x, direction.y, randomAngle);
            return Utils.normalizeVector(rotated.x, rotated.y);
        }

        createBullet(gunPos, direction, speed, damage, weapon, isPellet) {
            const offset = 12;
            this.game.bullets.push({
                x: gunPos.x + direction.x * offset,
                y: gunPos.y + direction.y * offset,
                velocityX: direction.x * speed,
                velocityY: direction.y * speed,
                damage: damage,
                maxRange: weapon.effectiveRange,
                isPellet: isPellet
            });
        }

        calculateFireDirection(gunPos) {
            const mouse = this.game.inputManager.mouse;
            return Utils.getDirection(gunPos.x, gunPos.y, mouse.x, mouse.y);
        }

        applyRecoil(direction, weapon) {
            const player = this.game.player;
            player.velocityX -= direction.x * weapon.knockback;
            player.velocityY -= direction.y * weapon.knockback * 0.2;
            this.game.effectsManager.addScreenShake(weapon.recoilKick);
        }

        createMuzzleFlash(gunPos, direction, weapon) {
            const offset = 12;
            this.game.effectsManager.createMuzzleFlash(
                gunPos.x + direction.x * offset,
                gunPos.y + direction.y * offset,
                weapon.flashTime
            );
        }

        consumeAmmo(weapon) {
            if (weapon.ammo && weapon.ammo.current > 0) {
                weapon.ammo.current--;
            }
        }

        getMeleeHitBox(weapon) {
            const player = this.game.player;
            return {
                x: player.facingRight ? player.x + player.width : player.x - weapon.range,
                y: player.y,
                width: weapon.range,
                height: player.height
            };
        }

        checkMeleeHits(hitBox, weapon) {
            let hitAny = false;
            const zombies = this.game.zombies;
            
            for (let i = zombies.length - 1; i >= 0; i--) {
                const zombie = zombies[i];
                if (Utils.checkCollision(
                    hitBox.x, hitBox.y, hitBox.width, hitBox.height,
                    zombie.x, zombie.y, zombie.width, zombie.height
                )) {
                    const zombieDied = this.game.damageZombie(zombie, weapon.damage);
                    hitAny = true;
                    
                    if (zombieDied) {
                        zombies.splice(i, 1);
                    }
                }
            }
            return hitAny;
        }

        getGunPosition() {
            const player = this.game.player;
            const centerX = player.x + player.width / 2;
            const centerY = player.y + (player.height * 0.65);
            const offsetX = player.facingRight ? 8 : -8;
            return { x: centerX + offsetX, y: centerY };
        }

        reloadCurrentWeapon() {
            const weapon = this.getCurrentWeapon();
            if (!this.canReload(weapon)) return;
            
            this.startReload(weapon);
        }

        canReload(weapon) {
            return weapon && 
                   weapon.type !== 'melee' && 
                   weapon.ammo && 
                   weapon.ammo.current < weapon.ammo.max && 
                   !weapon.isReloading;
        }

        startReload(weapon) {
            weapon.isReloading = true;
            weapon.reloadStartTime = this.game.timeElapsed;
            weapon.reloadEndTime = this.game.timeElapsed + weapon.reloadTime;
        }

        checkReloadProgress() {
            Object.values(this.inventory).forEach(weapon => {
                if (weapon.isReloading && this.game.timeElapsed >= weapon.reloadEndTime) {
                    this.completeReload(weapon);
                }
            });
        }

        completeReload(weapon) {
            weapon.isReloading = false;
            weapon.ammo.current = weapon.ammo.max;
            weapon.reloadStartTime = null;
            weapon.reloadEndTime = null;
        }

        resetWeaponStates() {
            Object.values(this.inventory).forEach(weapon => {
                weapon.emptyClickPlayed = false;
                weapon.wasFiring = false;
            });
        }
    }

    // =====================================================
    // SHOP SYSTEM
    // =====================================================
    class ShopSystem {
        constructor(game) {
            this.game = game;
            this.shopOpen = false;
            this.selectedShopItem = null;
            this.merchant = this.createMerchant();
            this.initializeUI();
        }

        createMerchant() {
            return {
                x: CONFIG.MERCHANT_X,
                y: 0,
                width: CONFIG.PLAYER_WIDTH,
                height: CONFIG.PLAYER_HEIGHT,
                facingRight: true,
                interactionRange: CONFIG.MERCHANT_INTERACTION_RANGE
            };
        }

        initializeUI() {
            document.getElementById('buyButton').addEventListener('click', () => this.buySelectedItem());
            document.getElementById('closeShopButton').addEventListener('click', () => this.closeShop());
        }

        update() {
            if (this.shopOpen) {
                if (!this.canShopBeOpen()) {
                    this.closeShop();
                }
            }
        }

        canShopBeOpen() {
            return this.game.waveSystem.gameStage === 'peaceful' && 
                   this.getPlayerDistance() <= this.merchant.interactionRange;
        }

        getPlayerDistance() {
            const player = this.game.player;
            const playerCenterX = player.x + player.width / 2;
            const merchantCenterX = this.merchant.x + this.merchant.width / 2;
            return Math.abs(playerCenterX - merchantCenterX);
        }

        tryOpenShop() {
            if (this.shopOpen || this.game.waveSystem.gameStage !== 'peaceful') return;
            
            if (this.getPlayerDistance() <= this.merchant.interactionRange) {
                this.openShop();
            }
        }

        openShop() {
            this.shopOpen = true;
            this.selectedShopItem = null;
            this.updateShopInterface();
            document.getElementById('shopInterface').style.display = 'block';
        }

        closeShop() {
            this.shopOpen = false;
            this.selectedShopItem = null;
            document.getElementById('shopInterface').style.display = 'none';
        }

        updateShopInterface() {
            const container = document.getElementById('shopItems');
            container.innerHTML = '';
            
            Object.values(SHOP_ITEMS).forEach(item => {
                container.appendChild(this.createShopItemElement(item));
            });
            
            document.getElementById('buyButton').disabled = true;
        }

        createShopItemElement(item) {
            const element = document.createElement('div');
            element.className = 'shopItem';
            element.dataset.itemId = item.id;
            
            const isEquipped = this.game.weaponSystem.inventory.primary.id === item.id;
            
            element.innerHTML = `
                <div class="shopItemInfo">
                    <div class="shopItemName">${item.name}${isEquipped ? ' (EQUIPPED)' : ''}</div>
                    <div class="shopItemStats">${item.stats}</div>
                </div>
            `;
            
            if (isEquipped) {
                element.setAttribute('disabled', 'true');
            } else {
                element.addEventListener('click', () => this.selectShopItem(item));
            }
            
            return element;
        }

        selectShopItem(item) {
            this.selectedShopItem = item;
            
            document.querySelectorAll('.shopItem').forEach(el => {
                el.classList.remove('selected');
            });
            
            document.querySelector(`[data-item-id="${item.id}"]`)?.classList.add('selected');
            document.getElementById('buyButton').disabled = false;
        }

        buySelectedItem() {
            if (!this.selectedShopItem) return;
            
            this.game.weaponSystem.inventory.primary = 
                this.game.weaponSystem.createWeaponInstance(this.selectedShopItem.weapon);
            this.game.weaponSystem.currentSlot = 'primary';
            this.closeShop();
        }

        setMerchantPosition(y) {
            this.merchant.y = y;
        }
    }

    // =====================================================
    // WAVE SYSTEM
    // =====================================================
    class WaveSystem {
        constructor(game) {
            this.game = game;
            this.gameStage = 'peaceful';
            this.currentWave = 1;
            this.waveTimer = null;
            this.isSpawningWave = false;
            this.spawnTimers = [];
            this.initializeUI();
        }

        initializeUI() {
            const button = document.getElementById('waveControl');
            button.addEventListener('click', () => this.toggleGameStage());
            this.updateButtonState();
        }

        updateButtonState() {
            const button = document.getElementById('waveControl');
            if (this.gameStage === 'peaceful') {
                button.textContent = 'START WAVES';
                button.style.borderColor = '#e53935';
            } else {
                button.textContent = 'STOP WAVES';
                button.style.borderColor = '#ffd54a';
            }
        }

        toggleGameStage() {
            if (this.gameStage === 'peaceful') {
                this.startWaves();
            } else {
                this.stopWaves();
            }
        }

        startWaves() {
            this.gameStage = 'waves';
            this.spawnWave(this.currentWave);
            this.updateButtonState();
        }

        stopWaves() {
            this.gameStage = 'peaceful';
            this.game.zombies = [];
            this.isSpawningWave = false;
            this.clearAllTimers();
            this.updateButtonState();
        }

        clearAllTimers() {
            this.spawnTimers.forEach(timer => clearTimeout(timer));
            this.spawnTimers = [];
            
            if (this.waveTimer) {
                clearTimeout(this.waveTimer);
                this.waveTimer = null;
            }
        }

        spawnWave(waveNumber) {
            const zombieCount = this.calculateZombieCount(waveNumber);
            
            this.game.effectsManager.showWaveAnnouncement(waveNumber);
            this.isSpawningWave = true;
            this.spawnTimers = [];
            
            this.scheduleZombieSpawns(zombieCount, waveNumber);
        }

        calculateZombieCount(waveNumber) {
            return 2 + (waveNumber - 1) * 2;
        }

        scheduleZombieSpawns(zombieCount, waveNumber) {
            let zombiesSpawned = 0;
            
            const spawnNextZombie = () => {
                if (this.gameStage !== 'waves') {
                    this.isSpawningWave = false;
                    return;
                }
                
                if (zombiesSpawned < zombieCount) {
                    const type = this.selectZombieType(waveNumber, zombiesSpawned);
                    this.game.spawnZombie(this.game.canvas.width + 50, type);
                    zombiesSpawned++;
                    
                    if (zombiesSpawned < zombieCount) {
                        const timer = setTimeout(spawnNextZombie, CONFIG.ZOMBIE_SPAWN_DELAY);
                        this.spawnTimers.push(timer);
                    } else {
                        this.isSpawningWave = false;
                    }
                }
            };
            
            const initialTimer = setTimeout(spawnNextZombie, CONFIG.ZOMBIE_SPAWN_INITIAL_DELAY);
            this.spawnTimers.push(initialTimer);
        }

        selectZombieType(waveNumber, spawnIndex) {
            const availableTypes = WAVE_ZOMBIE_TYPES[Math.min(waveNumber, 5)];
            
            // First zombie of special waves is guaranteed special type
            if (spawnIndex === 0 && waveNumber <= 4) {
                return availableTypes[0];
            }
            
            // Random selection for other zombies
            const weights = this.getZombieTypeWeights(waveNumber);
            return this.weightedRandomSelection(availableTypes, weights);
        }

        getZombieTypeWeights(waveNumber) {
            if (waveNumber <= 2) return [0.7, 0.3];
            if (waveNumber === 3) return [0.2, 0.5, 0.3];
            if (waveNumber === 4) return [0.1, 0.4, 0.3, 0.2];
            return [0.4, 0.3, 0.2, 0.1];
        }

        weightedRandomSelection(types, weights) {
            const random = Math.random();
            let cumulative = 0;
            
            for (let i = 0; i < types.length && i < weights.length; i++) {
                cumulative += weights[i];
                if (random < cumulative) {
                    return types[i];
                }
            }
            
            return types[types.length - 1];
        }

        checkWaveCompletion() {
            if (this.gameStage !== 'waves' || this.isSpawningWave || this.waveTimer) return;
            
            if (this.game.zombies.length === 0) {
                this.scheduleNextWave();
            }
        }

        scheduleNextWave() {
            this.waveTimer = setTimeout(() => {
                if (this.gameStage === 'waves') {
                    this.currentWave++;
                    this.spawnWave(this.currentWave);
                    this.waveTimer = null;
                }
            }, CONFIG.WAVE_DELAY);
        }

        reset() {
            this.gameStage = 'peaceful';
            this.currentWave = 1;
            this.isSpawningWave = false;
            this.clearAllTimers();
            this.updateButtonState();
        }
    }

    // =====================================================
    // EFFECTS MANAGER
    // =====================================================
    class EffectsManager {
        constructor(game) {
            this.game = game;
            this.screenShake = 0;
            this.muzzleFlash = { active: false, timer: 0, x: 0, y: 0 };
            this.meleeSlash = { active: false, timer: 0, x: 0, y: 0, facingRight: true };
            this.waveAnnouncement = { active: false, timer: 0, text: '' };
            this.hitEffects = [];
        }

        update(dt) {
            this.updateScreenShake(dt);
            this.updateTimedEffect(this.muzzleFlash, dt);
            this.updateTimedEffect(this.meleeSlash, dt);
            this.updateTimedEffect(this.waveAnnouncement, dt);
            this.updateHitEffects(dt);
        }

        updateScreenShake(dt) {
            if (this.screenShake > 0) {
                this.screenShake = Math.max(0, this.screenShake - CONFIG.SCREEN_SHAKE_DECAY * dt);
            }
        }

        updateTimedEffect(effect, dt) {
            if (effect.active) {
                effect.timer -= dt;
                if (effect.timer <= 0) {
                    effect.active = false;
                }
            }
        }

        updateHitEffects(dt) {
            this.hitEffects = this.hitEffects.filter(effect => {
                effect.timer -= dt;
                return effect.timer > 0;
            });
        }

        addScreenShake(amount) {
            this.screenShake = Math.max(this.screenShake, amount);
        }

        createMuzzleFlash(x, y, duration) {
            this.muzzleFlash = { active: true, timer: duration, x, y };
        }

        createMeleeSlash(position, facingRight) {
            this.meleeSlash = {
                active: true,
                timer: 0.15,
                x: position.x,
                y: position.y,
                facingRight
            };
        }

        createHitEffect(x, y, type, hitData = null) {
            const effectTimer = type === 'headshot' ? 0.15 : 0.3;
            this.hitEffects.push({
                x, y, type,
                timer: effectTimer,
                maxTimer: effectTimer,
                hitData
            });
        }

        showWaveAnnouncement(waveNumber) {
            this.waveAnnouncement = {
                active: true,
                timer: 3.0,
                text: `WAVE ${waveNumber}`
            };
        }

        getScreenShake() {
            if (this.screenShake <= 0) return { x: 0, y: 0 };
            return {
                x: (Math.random() * 2 - 1) * this.screenShake * 0.3,
                y: (Math.random() * 2 - 1) * this.screenShake * 0.3
            };
        }
    }

    // =====================================================
    // RENDERER
    // =====================================================
    class Renderer {
        constructor(game) {
            this.game = game;
            this.ctx = game.ctx;
            this.clouds = Utils.shuffleArray([...CLOUD_SPRITES]);
            this.cloudOffset = 0;
        }

        render() {
            this.clearScreen();
            const shake = this.game.effectsManager.getScreenShake();

            this.renderBackground();
            this.renderGround();
            this.renderEntities(shake);
            this.renderProjectiles();
            this.renderEffects(shake);
            this.renderUI();
            
            if (this.game.gameOver) {
                this.renderGameOver();
            }
        }

        clearScreen() {
            this.ctx.clearRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        }

        renderBackground() {
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
            this.renderClouds();
        }

        renderClouds() {
            const baseY = this.game.canvas.height * 0.25;
            this.cloudOffset += CONFIG.CLOUD_SPEED;
            
            let cloudsVisible = 0;
            
            for (let i = 0; i < this.clouds.length; i++) {
                const cloudX = (i * CONFIG.CLOUD_SPACING - this.cloudOffset + this.game.canvas.width + 200);
                if (cloudX > -400 && cloudX < this.game.canvas.width + 400) {
                    const variation = Math.sin(cloudX * 0.01) * 15;
                    this.drawCloudSprite(this.clouds[i], cloudX, baseY + variation);
                    cloudsVisible++;
                }
            }
            
            if (cloudsVisible === 0) {
                this.clouds = Utils.shuffleArray([...CLOUD_SPRITES]);
                this.cloudOffset = 0;
            }
        }

        drawCloudSprite(sprite, offsetX, baseY) {
            const pixelSize = CONFIG.CLOUD_PIXEL_SIZE;
            const spriteWidth = sprite[0].length;
            const spriteHeight = sprite.length;
            const cloudWidth = spriteWidth * pixelSize;
            const cloudHeight = spriteHeight * pixelSize;
            const startX = offsetX + (110 - cloudWidth) / 2;
            const startY = baseY - cloudHeight;

            for (let row = 0; row < spriteHeight; row++) {
                const line = sprite[row];
                for (let col = 0; col < spriteWidth; col++) {
                    if (line[col] === 'b') {
                        this.ctx.fillStyle = PALETTE.cloudDark;
                        this.ctx.fillRect(
                            Math.floor(startX + col * pixelSize),
                            Math.floor(startY + row * pixelSize),
                            Math.ceil(pixelSize),
                            Math.ceil(pixelSize)
                        );
                    }
                }
            }
        }

        renderGround() {
            const y = this.game.canvas.height - CONFIG.GROUND_HEIGHT;

            this.ctx.fillStyle = '#3d2b1f';
            this.ctx.fillRect(0, y + 20, this.game.canvas.width, 20);

            this.ctx.fillStyle = '#2d4a2d';
            this.ctx.fillRect(0, y + 10, this.game.canvas.width, 10);

            this.ctx.fillStyle = '#4a7c59';
            this.ctx.fillRect(0, y, this.game.canvas.width, 10);

            this.ctx.fillStyle = PALETTE.outline;
            this.ctx.fillRect(0, y - 1, this.game.canvas.width, 1);
        }

        renderEntities(shake) {
            this.renderPlayer(shake);
            this.renderMerchant();
            this.renderWeapon(shake);
            this.renderZombies();
        }

        renderPlayer(shake) {
            const player = this.game.player;
            const sprite = player.facingRight ? SPRITES.player.right : SPRITES.player.left;
            this.drawSprite(
                sprite,
                Math.floor(player.x + shake.x),
                Math.floor(player.y + shake.y),
                player.width,
                player.height
            );
        }

        renderMerchant() {
            const merchant = this.game.shopSystem.merchant;
            const sprite = SPRITES.merchant.right;
            this.drawSprite(sprite, Math.floor(merchant.x), Math.floor(merchant.y), merchant.width, merchant.height);
        }

        renderWeapon(shake) {
            const weapon = this.game.weaponSystem.getCurrentWeapon();
            const gunPos = this.game.weaponSystem.getGunPosition();
            const x = Math.floor(gunPos.x + shake.x);
            const y = Math.floor(gunPos.y + shake.y);

            if (weapon.type === 'melee') {
                const angle = this.game.player.facingRight ? 0 : Math.PI;
                const offsetX = this.game.player.facingRight ? 4 : -4;
                this.drawWeaponSprite(weapon.sprite, x + offsetX, y, angle);
            } else {
                const mouse = this.game.inputManager.mouse;
                const angle = Math.atan2(mouse.y - gunPos.y, mouse.x - gunPos.x);
                this.drawWeaponSprite(weapon.sprite, x, y, angle);
            }
        }

        renderZombies() {
            this.game.zombies.forEach(zombie => {
                const spriteSet = SPRITES[zombie.spriteKey];
                const sprite = zombie.facingRight ? spriteSet.right : spriteSet.left;
                this.drawSprite(sprite, Math.floor(zombie.x), Math.floor(zombie.y), zombie.width, zombie.height);
                this.renderEntityHealthBar(zombie);
            });
        }

        renderEntityHealthBar(entity) {
            const barWidth = entity.width;
            const barHeight = 4;
            const barX = Math.floor(entity.x);
            const barY = Math.floor(entity.y) - 6;

            // Render shield bar for tank zombies
            if (entity.shieldHP !== undefined && entity.shieldHP > 0) {
                this.renderShieldBar(entity, barX, barY - 8, barWidth, barHeight);
            }

            // Render health bar
            this.renderHealthBarAt(barX, barY, barWidth, barHeight, entity.hp, entity.maxHP);
        }

        renderShieldBar(entity, x, y, width, height) {
            const shieldRatio = entity.shieldHP / entity.maxShieldHP;
            
            this.ctx.fillStyle = '#444';
            this.ctx.fillRect(x, y, width, height);
            
            this.ctx.fillStyle = shieldRatio > 0.5 ? '#8B4513' : 
                                (shieldRatio > 0.2 ? '#A0522D' : '#654321');
            this.ctx.fillRect(x, y, Math.floor(width * shieldRatio), height);
        }

        renderHealthBarAt(x, y, width, height, hp, maxHP) {
            const hpRatio = hp / maxHP;
            
            this.ctx.fillStyle = '#222';
            this.ctx.fillRect(x, y, width, height);

            this.ctx.fillStyle = hpRatio > 0.5 ? PALETTE.hpHi : 
                                (hpRatio > 0.2 ? PALETTE.hpMid : PALETTE.hpLow);
            this.ctx.fillRect(x, y, Math.floor(width * hpRatio), height);
        }

        renderProjectiles() {
            this.renderBullets();
            this.renderAcidProjectiles();
        }

        renderBullets() {
            this.game.bullets.forEach(bullet => {
                this.ctx.fillStyle = bullet.isPellet ? PALETTE.bulletPellet : PALETTE.bullet;
                const size = bullet.isPellet ? 2 : 3;
                this.ctx.fillRect(
                    Math.floor(bullet.x - size / 2),
                    Math.floor(bullet.y - size / 2),
                    size, size
                );
            });
        }

        renderAcidProjectiles() {
            this.game.acidProjectiles.forEach(projectile => {
                const sprite = SPRITES.effects.acid;
                if (sprite && sprite.length > 0) {
                    this.drawSprite(sprite, Math.floor(projectile.x - 4), Math.floor(projectile.y - 4), 8, 8);
                } else {
                    this.ctx.fillStyle = PALETTE.acid;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.floor(projectile.x), Math.floor(projectile.y), 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
            });
        }

        renderEffects(shake) {
            const effects = this.game.effectsManager;
            
            this.renderMuzzleFlash(effects.muzzleFlash);
            this.renderMeleeSlash(effects.meleeSlash);
            this.renderWaveAnnouncement(effects.waveAnnouncement);
            this.renderHitEffects(effects.hitEffects);
        }

        renderMuzzleFlash(muzzleFlash) {
            if (!muzzleFlash.active) return;
            
            const radius = 1 + Math.floor(Math.random() * 2);
            this.ctx.fillStyle = PALETTE.muzzleFlash;
            this.ctx.fillRect(
                Math.floor(muzzleFlash.x) - radius,
                Math.floor(muzzleFlash.y) - radius,
                radius * 2 + 1,
                radius * 2 + 1
            );
        }

        renderMeleeSlash(meleeSlash) {
            if (!meleeSlash.active) return;
            
            this.ctx.save();
            this.ctx.strokeStyle = PALETTE.white;
            this.ctx.lineWidth = 3;
            this.ctx.globalAlpha = meleeSlash.timer / 0.15;

            const slashLength = 18;
            this.ctx.beginPath();
            this.ctx.moveTo(Math.floor(meleeSlash.x), Math.floor(meleeSlash.y));
            const endX = meleeSlash.facingRight ? 
                Math.floor(meleeSlash.x) + slashLength : 
                Math.floor(meleeSlash.x) - slashLength;
            this.ctx.lineTo(endX, Math.floor(meleeSlash.y));
            this.ctx.stroke();
            this.ctx.restore();
        }

        renderWaveAnnouncement(announcement) {
            if (!announcement.active) return;
            
            this.ctx.save();
            this.ctx.font = 'bold 48px monospace';
            this.ctx.textAlign = 'center';
            this.ctx.globalAlpha = Math.min(1, announcement.timer / 0.5);
            
            const centerX = this.game.canvas.width / 2;
            const centerY = this.game.canvas.height / 2;
            
            this.ctx.fillStyle = PALETTE.black;
            this.ctx.fillText(announcement.text, centerX + 2, centerY + 2);
            
            this.ctx.fillStyle = '#ffd54a';
            this.ctx.fillText(announcement.text, centerX, centerY);
            
            this.ctx.restore();
        }

        renderHitEffects(hitEffects) {
            hitEffects.forEach(effect => {
                const alpha = effect.timer / effect.maxTimer;
                this.ctx.save();
                this.ctx.globalAlpha = alpha;
                
                const sprite = SPRITES.effects[effect.type];
                if (sprite && sprite.length > 0) {
                    const size = effect.type === 'headshot' ? 16 : 8;
                    const offset = size / 2;
                    this.drawSprite(sprite, Math.floor(effect.x - offset), Math.floor(effect.y - offset), size, size);
                } else {
                    const color = this.getEffectColor(effect.type);
                    this.ctx.fillStyle = color;
                    this.ctx.beginPath();
                    this.ctx.arc(Math.floor(effect.x), Math.floor(effect.y), 3, 0, Math.PI * 2);
                    this.ctx.fill();
                }
                
                this.ctx.restore();
            });
        }

        getEffectColor(type) {
            const colorMap = {
                'headshot': PALETTE.headshot,
                'spark': PALETTE.yellow,
                'blood': PALETTE.red
            };
            return colorMap[type] || PALETTE.red;
        }

        renderUI() {
            this.renderPlayerHealthBar();
            this.renderWeaponSlots();
            this.renderWaveInfo();
            this.renderMerchantHint();
            
            if (CONFIG.DEBUG_MODE) {
                this.renderDebugInfo();
            }
        }

        renderPlayerHealthBar() {
            const player = this.game.player;
            const x = 10;
            const y = 20;
            const width = CONFIG.HP_BAR_WIDTH;
            const height = CONFIG.HP_BAR_HEIGHT;

            this.ctx.fillStyle = '#111';
            this.ctx.fillRect(x - 2, y - 2, width + 4, height + 4);

            this.renderHealthBarAt(x, y, width, height, player.hp, player.maxHP);

            this.ctx.strokeStyle = '#555';
            this.ctx.strokeRect(x, y, width, height);

            this.ctx.font = '14px monospace';
            this.ctx.fillStyle = '#bbb';
            this.ctx.fillText(`HP: ${player.hp}/${player.maxHP}`, x, y - 4);
        }

        renderWeaponSlots() {
            const slots = ['primary', 'secondary', 'melee'];
            const weaponSystem = this.game.weaponSystem;
            const startX = 10;
            const startY = 48;

            slots.forEach((slot, index) => {
                this.renderWeaponSlot(slot, index, startX, startY, weaponSystem);
            });
        }

        renderWeaponSlot(slot, index, startX, startY, weaponSystem) {
            const x = startX + index * (CONFIG.WEAPON_SLOT_WIDTH + CONFIG.WEAPON_SLOT_PADDING);
            const y = startY;
            const width = CONFIG.WEAPON_SLOT_WIDTH;
            const height = CONFIG.WEAPON_SLOT_HEIGHT;

            this.ctx.save();

            // Background
            this.ctx.fillStyle = '#111';
            this.ctx.fillRect(x, y, width, height);

            // Border
            this.ctx.strokeStyle = slot === weaponSystem.currentSlot ? '#ffd54a' : '#555';
            this.ctx.lineWidth = slot === weaponSystem.currentSlot ? 2 : 1;
            this.ctx.strokeRect(x, y, width, height);

            // Slot label
            this.ctx.fillStyle = '#bbb';
            this.ctx.font = '14px monospace';
            this.ctx.fillText(`${index + 1}. ${slot.toUpperCase()}`, x + 8, y + 14);

            // Weapon info
            const weapon = weaponSystem.inventory[slot];
            if (weapon) {
                this.ctx.fillStyle = '#9cf';
                this.ctx.font = '14px monospace';
                this.ctx.fillText(weapon.name, x + 8, y + 32);
                
                if (weapon.type !== 'melee' && weapon.ammo) {
                    this.renderWeaponAmmoInfo(weapon, x, y);
                }
            } else {
                this.ctx.fillStyle = '#888';
                this.ctx.font = '14px monospace';
                this.ctx.fillText('Empty', x + 8, y + 32);
            }
            
            this.ctx.restore();
        }

        renderWeaponAmmoInfo(weapon, x, y) {
            if (weapon.isReloading) {
                this.renderReloadingBar(weapon, x, y);
            } else {
                this.ctx.fillStyle = '#ffd54a';
                this.ctx.font = '12px monospace';
                this.ctx.fillText(`${weapon.ammo.current}/${weapon.ammo.max}`, x + 8, y + 50);
            }
        }

        renderReloadingBar(weapon, x, y) {
            this.ctx.fillStyle = '#ff5555';
            this.ctx.font = '10px monospace';
            this.ctx.fillText('RELOADING', x + 8, y + 48);
            
            const barWidth = 94;
            const barHeight = 4;
            const barX = x + 8;
            const barY = y + 54;
            
            // Background
            this.ctx.fillStyle = '#333';
            this.ctx.fillRect(barX, barY, barWidth, barHeight);
            
            // Progress
            const progress = (this.game.timeElapsed - weapon.reloadStartTime) / weapon.reloadTime;
            const clampedProgress = Utils.clamp(progress, 0, 1);
            
            this.ctx.fillStyle = '#ff5555';
            this.ctx.fillRect(barX, barY, Math.floor(barWidth * clampedProgress), barHeight);
            
            // Border
            this.ctx.strokeStyle = '#555';
            this.ctx.lineWidth = 1;
            this.ctx.strokeRect(barX, barY, barWidth, barHeight);
        }

        renderWaveInfo() {
            const buttonElement = document.getElementById('waveControl');
            if (!buttonElement) return;
            
            const buttonRect = buttonElement.getBoundingClientRect();
            const waveX = buttonRect.left + (buttonRect.width / 2) - 40;
            const waveY = buttonRect.bottom + 25;
            
            this.ctx.fillStyle = '#ffd54a';
            this.ctx.font = 'bold 16px monospace';
            this.ctx.fillText(`WAVE ${this.game.waveSystem.currentWave}`, waveX, waveY);
        }

        renderMerchantHint() {
            if (this.game.waveSystem.gameStage !== 'peaceful') return;
            
            const distance = this.game.shopSystem.getPlayerDistance();
            const merchant = this.game.shopSystem.merchant;
            
            if (distance <= merchant.interactionRange) {
                this.ctx.fillStyle = PALETTE.white;
                this.ctx.font = '16px monospace';
                this.ctx.textAlign = 'center';
                
                const merchantCenterX = merchant.x + merchant.width / 2;
                const textY = merchant.y - 20;
                
                this.ctx.fillText('Press E to open shop', merchantCenterX, textY);
                this.ctx.textAlign = 'left';
            }
        }

        renderDebugInfo() {
            this.ctx.fillStyle = '#666';
            this.ctx.font = '10px monospace';
            this.ctx.fillText(`v${CONFIG.GAME_VERSION}`, this.game.canvas.width - 80, 20);
            
            if (CONFIG.DEBUG_MODE) {
                this.renderHeadshotZones();
            }
        }

        renderHeadshotZones() {
            this.game.zombies.forEach(zombie => {
                const spriteSet = SPRITES[zombie.spriteKey];
                const sprite = zombie.facingRight ? spriteSet.right : spriteSet.left;
                
                if (!sprite || sprite.length === 0) return;
                
                const { originY, cellHeight } = this.getSpriteMetrics(sprite, zombie);
                const headshotHeight = Math.ceil(sprite.length * CONFIG.HEADSHOT_ZONE_HEIGHT_RATIO) * cellHeight;
                
                this.ctx.strokeStyle = '#ff0000';
                this.ctx.lineWidth = 2;
                this.ctx.setLineDash([5, 5]);
                this.ctx.strokeRect(zombie.x, originY, zombie.width, headshotHeight);
                this.ctx.setLineDash([]);
            });
        }

        renderGameOver() {
            this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            this.ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);

            this.ctx.fillStyle = '#ff5555';
            this.ctx.font = 'bold 32px monospace';
            this.ctx.fillText('YOU DIED', this.game.canvas.width / 2 - 90, this.game.canvas.height / 2 - 6);

            this.ctx.fillStyle = '#ccc';
            this.ctx.font = '16px monospace';
            this.ctx.fillText('Press R or Space to restart', this.game.canvas.width / 2 - 120, this.game.canvas.height / 2 + 24);
        }

        drawSprite(sprite, x, y, width, height) {
            if (!sprite || !Array.isArray(sprite) || sprite.length === 0) return;

            const { scaleX, scaleY, originX, originY } = this.getSpriteDrawParams(sprite, x, y, width, height);
            const cellWidth = Math.max(1, scaleX);
            const cellHeight = Math.max(1, scaleY);

            for (let row = 0; row < sprite.length; row++) {
                const line = sprite[row];
                if (!line || typeof line !== 'string') continue;
                
                for (let col = 0; col < line.length; col++) {
                    const char = line[col];
                    if (char === '.') continue;
                    
                    const colorKey = SPRITE_COLOR_MAP[char];
                    if (!colorKey) continue;
                    
                    this.ctx.fillStyle = PALETTE[colorKey];
                    this.ctx.fillRect(
                        Math.floor(originX + col * cellWidth),
                        Math.floor(originY + row * cellHeight),
                        cellWidth,
                        cellHeight
                    );
                }
            }
        }

        getSpriteDrawParams(sprite, x, y, width, height) {
            const actualWidth = sprite[0].length;
            const actualHeight = sprite.length;
            const scaleX = Math.floor(width / actualWidth);
            const scaleY = Math.floor(height / actualHeight);
            const cellWidth = Math.max(1, scaleX);
            const cellHeight = Math.max(1, scaleY);
            const originX = Math.floor(x + (width - actualWidth * cellWidth) / 2);
            const originY = Math.floor(y + (height - actualHeight * cellHeight));
            
            return { scaleX, scaleY, originX, originY, actualWidth, actualHeight };
        }

        getSpriteMetrics(sprite, entity) {
            const spriteHeight = sprite.length;
            const scaleY = Math.floor(entity.height / spriteHeight);
            const cellHeight = Math.max(1, scaleY);
            const originY = Math.floor(entity.y + (entity.height - spriteHeight * cellHeight));
            
            return { originY, cellHeight };
        }

        drawWeaponSprite(spriteKey, x, y, angle) {
            const sprite = SPRITES.weapons[spriteKey];
            if (!sprite) return;

            const pixelSize = 3;
            this.ctx.save();
            this.ctx.translate(x, y);
            this.ctx.rotate(angle);

            if (Math.cos(angle) < 0) {
                this.ctx.scale(1, -1);
            }

            const spriteWidth = sprite[0].length;
            const spriteHeight = sprite.length;
            const startX = -(spriteWidth * pixelSize) / 2;
            const startY = -(spriteHeight * pixelSize) / 2;

            for (let row = 0; row < spriteHeight; row++) {
                const line = sprite[row];
                for (let col = 0; col < spriteWidth; col++) {
                    if (line[col] === 'b') {
                        this.ctx.fillStyle = PALETTE.gunMetal;
                        this.ctx.fillRect(
                            Math.floor(startX + col * pixelSize - 0.5),
                            Math.floor(startY + row * pixelSize - 0.5),
                            pixelSize + 1,
                            pixelSize + 1
                        );
                    }
                }
            }

            this.ctx.restore();
        }
    }

    // =====================================================
    // PHYSICS ENGINE
    // =====================================================
    class PhysicsEngine {
        constructor(game) {
            this.game = game;
        }

        update(dt) {
            this.updatePlayer(dt);
            this.updateBullets(dt);
            this.updateAcidProjectiles(dt);
            this.updateZombies(dt);
        }

        updatePlayer(dt) {
            const player = this.game.player;
            const input = this.game.inputManager;
            
            // Horizontal movement
            const moveDir = (input.keys.a ? -1 : 0) + (input.keys.d ? 1 : 0);
            player.velocityX += (moveDir * CONFIG.PLAYER_MOVE_SPEED - player.velocityX) * 0.4;
            player.x += player.velocityX * dt;
            player.x = Utils.clamp(player.x, 0, this.game.canvas.width - player.width);

            // Vertical movement (gravity)
            player.velocityY += CONFIG.GRAVITY * dt;
            player.y += player.velocityY * dt;

            // Ground collision
            const groundY = Utils.getGroundY(this.game.canvas.height, player.height);
            if (player.y > groundY) {
                player.y = groundY;
                player.velocityY = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            // Ceiling collision
            if (player.y < 0) {
                player.y = 0;
                player.velocityY = 0;
            }

            // Update facing direction
            const centerX = player.x + player.width / 2;
            player.facingRight = input.mouse.x >= centerX;
        }

        updateBullets(dt) {
            const bullets = this.game.bullets;
            
            for (let i = bullets.length - 1; i >= 0; i--) {
                const bullet = bullets[i];

                // Apply gravity
                bullet.velocityY += CONFIG.BULLET_GRAVITY * dt;

                // Update position
                bullet.x += bullet.velocityX * dt;
                bullet.y += bullet.velocityY * dt;

                // Check zombie hits
                const hitResult = this.checkBulletHits(bullet);
                
                if (hitResult.hit) {
                    this.handleBulletHit(hitResult);
                    bullets.splice(i, 1);
                } else if (this.shouldRemoveBullet(bullet)) {
                    this.game.effectsManager.createHitEffect(bullet.x, bullet.y, 'spark');
                    bullets.splice(i, 1);
                }
            }
        }

        handleBulletHit(hitResult) {
            this.game.effectsManager.createHitEffect(hitResult.x, hitResult.y, hitResult.type, hitResult);
            
            if (hitResult.isHeadshot) {
                this.game.effectsManager.addScreenShake(8);
            }
        }

        checkBulletHits(bullet) {
            const zombies = this.game.zombies;
            
            for (let j = zombies.length - 1; j >= 0; j--) {
                const zombie = zombies[j];
                
                if (this.isBulletInBounds(bullet, zombie) && this.checkPixelPerfectCollision(bullet, zombie)) {
                    const isHeadshot = this.checkHeadshot(bullet, zombie);
                    const damage = isHeadshot ? 
                        Math.floor(bullet.damage * CONFIG.HEADSHOT_DAMAGE_MULTIPLIER) : 
                        bullet.damage;
                    
                    const zombieDied = this.game.damageZombie(zombie, damage);

                    if (zombieDied) {
                        zombies.splice(j, 1);
                    }
                    
                    return { 
                        hit: true, 
                        type: isHeadshot ? 'headshot' : 'blood', 
                        x: bullet.x, 
                        y: bullet.y,
                        isHeadshot,
                        damage,
                        originalDamage: bullet.damage
                    };
                }
            }
            
            return { hit: false };
        }

        isBulletInBounds(bullet, zombie) {
            return bullet.x >= zombie.x && bullet.x <= zombie.x + zombie.width &&
                   bullet.y >= zombie.y && bullet.y <= zombie.y + zombie.height;
        }

        checkPixelPerfectCollision(bullet, zombie) {
            const spriteSet = SPRITES[zombie.spriteKey];
            const sprite = zombie.facingRight ? spriteSet.right : spriteSet.left;
            
            if (!sprite || !Array.isArray(sprite) || sprite.length === 0) {
                return false;
            }

            const collision = this.getPixelCollisionPoint(bullet, zombie, sprite);
            return collision.hit;
        }

        checkHeadshot(bullet, zombie) {
            const spriteSet = SPRITES[zombie.spriteKey];
            const sprite = zombie.facingRight ? spriteSet.right : spriteSet.left;
            
            if (!sprite || !Array.isArray(sprite) || sprite.length === 0) {
                return false;
            }

            const collision = this.getPixelCollisionPoint(bullet, zombie, sprite);
            if (!collision.hit) return false;
            
            const headshotZoneHeight = Math.ceil(sprite.length * CONFIG.HEADSHOT_ZONE_HEIGHT_RATIO);
            return collision.spriteY < headshotZoneHeight;
        }

        getPixelCollisionPoint(bullet, zombie, sprite) {
            const spriteWidth = sprite[0].length;
            const spriteHeight = sprite.length;
            const scaleX = Math.floor(zombie.width / spriteWidth);
            const scaleY = Math.floor(zombie.height / spriteHeight);
            const cellWidth = Math.max(1, scaleX);
            const cellHeight = Math.max(1, scaleY);
            
            const originX = Math.floor(zombie.x + (zombie.width - spriteWidth * cellWidth) / 2);
            const originY = Math.floor(zombie.y + (zombie.height - spriteHeight * cellHeight));

            const relativeX = Math.floor(bullet.x - originX);
            const relativeY = Math.floor(bullet.y - originY);
            
            const spriteX = Math.floor(relativeX / cellWidth);
            const spriteY = Math.floor(relativeY / cellHeight);
            
            if (spriteX < 0 || spriteX >= spriteWidth || spriteY < 0 || spriteY >= spriteHeight) {
                return { hit: false };
            }
            
            const spriteChar = sprite[spriteY][spriteX];
            return { 
                hit: spriteChar !== '.', 
                spriteX, 
                spriteY 
            };
        }

        shouldRemoveBullet(bullet) {
            const groundY = this.game.canvas.height - CONFIG.GROUND_HEIGHT - CONFIG.GROUND_COLLISION_OFFSET;
            
            return bullet.x < -10 || bullet.x > this.game.canvas.width + 10 ||
                   bullet.y < -10 || bullet.y > this.game.canvas.height + 10 ||
                   bullet.y >= groundY;
        }

        updateAcidProjectiles(dt) {
            const projectiles = this.game.acidProjectiles;
            
            for (let i = projectiles.length - 1; i >= 0; i--) {
                const projectile = projectiles[i];

                projectile.x += projectile.velocityX * dt;
                projectile.y += projectile.velocityY * dt;

                if (this.checkAcidPlayerHit(projectile)) {
                    this.game.applyDamage(projectile.damage);
                    this.game.effectsManager.createHitEffect(projectile.x, projectile.y, 'blood');
                    projectiles.splice(i, 1);
                } else if (this.shouldRemoveProjectile(projectile)) {
                    this.game.effectsManager.createHitEffect(projectile.x, projectile.y, 'spark');
                    projectiles.splice(i, 1);
                }
            }
        }

        checkAcidPlayerHit(projectile) {
            const player = this.game.player;
            return Utils.checkEntityCollision(projectile, player);
        }

        shouldRemoveProjectile(projectile) {
            const groundY = this.game.canvas.height - CONFIG.GROUND_HEIGHT - CONFIG.GROUND_COLLISION_OFFSET;
            
            return projectile.x < -10 || projectile.x > this.game.canvas.width + 10 ||
                   projectile.y < -10 || projectile.y > this.game.canvas.height + 10 ||
                   projectile.y >= groundY;
        }

        updateZombies(dt) {
            this.game.zombies.forEach(zombie => {
                this.updateZombieAI(zombie, dt);
                this.keepZombieOnGround(zombie);
                this.checkZombiePlayerCollision(zombie);
            });
        }

        updateZombieAI(zombie, dt) {
            const player = this.game.player;
            const zombieCenterX = zombie.x + zombie.width / 2;
            const playerCenterX = player.x + player.width / 2;
            const distanceX = playerCenterX - zombieCenterX;
            const totalDistance = Utils.getDistance(zombie.x, zombie.y, player.x, player.y);
            
            if (zombie.spriteKey === 'zombieSpitter') {
                this.updateSpitterAI(zombie, player, totalDistance, distanceX, dt);
            } else {
                this.updateBasicZombieAI(zombie, distanceX, dt);
            }

            if (Math.abs(distanceX) > 5) {
                zombie.facingRight = distanceX > 0;
            }
        }

        updateBasicZombieAI(zombie, distanceX, dt) {
            const moveThreshold = 20;
            
            if (Math.abs(distanceX) > moveThreshold) {
                const dirX = Math.sign(distanceX);
                zombie.velocityX = dirX * zombie.speed;
                zombie.x += zombie.velocityX * dt;
                zombie.x = Utils.clamp(zombie.x, 0, this.game.canvas.width - zombie.width);
            } else {
                this.handleZombieStuck(zombie, dt);
            }
        }

        handleZombieStuck(zombie, dt) {
            if (!zombie.stuckTimer) zombie.stuckTimer = 0;
            zombie.stuckTimer += dt;
            
            if (zombie.stuckTimer > 1.0) {
                zombie.velocityX = (Math.random() - 0.5) * 30;
                zombie.stuckTimer = 0;
            } else {
                zombie.velocityX = 0;
            }
        }

        updateSpitterAI(zombie, player, totalDistance, distanceX, dt) {
            const idealRange = zombie.attackRange;
            
            if (totalDistance < idealRange * 0.7) {
                // Too close, back away
                this.moveZombie(zombie, -Math.sign(distanceX), zombie.speed * 0.8, dt);
            } else if (totalDistance > idealRange * 1.2) {
                // Too far, move closer
                this.moveZombie(zombie, Math.sign(distanceX), zombie.speed * 0.6, dt);
            } else {
                // In range, stop and attack
                zombie.velocityX = 0;
                this.trySpitterAttack(zombie, player);
            }
        }

        moveZombie(zombie, direction, speed, dt) {
            zombie.velocityX = direction * speed;
            zombie.x += zombie.velocityX * dt;
            zombie.x = Utils.clamp(zombie.x, 0, this.game.canvas.width - zombie.width);
        }

        trySpitterAttack(zombie, player) {
            const now = this.game.timeElapsed;
            if (now - zombie.lastAttackTime < zombie.attackCooldown) return;
            
            const direction = Utils.getDirection(
                zombie.x + zombie.width / 2,
                zombie.y + zombie.height / 2,
                player.x + player.width / 2,
                player.y + player.height / 2
            );
            
            this.createAcidProjectile(zombie, direction);
            zombie.lastAttackTime = now;
            this.game.effectsManager.addScreenShake(3);
        }

        createAcidProjectile(zombie, direction) {
            this.game.acidProjectiles.push({
                x: zombie.x + zombie.width / 2,
                y: zombie.y + zombie.height / 2,
                width: 6,
                height: 6,
                velocityX: direction.x * zombie.projectileSpeed,
                velocityY: direction.y * zombie.projectileSpeed,
                damage: zombie.projectileDamage
            });
        }

        keepZombieOnGround(zombie) {
            zombie.y = Utils.getGroundY(this.game.canvas.height, zombie.height);
        }

        checkZombiePlayerCollision(zombie) {
            const player = this.game.player;
            
            if (!Utils.checkEntityCollision(player, zombie)) return;
            
            this.handleZombieTouchDamage(zombie);
            this.applyCollisionSeparation(player, zombie);
        }

        handleZombieTouchDamage(zombie) {
            const now = this.game.timeElapsed;
            if (now - zombie.lastHitTime >= zombie.hitCooldown) {
                this.game.applyDamage(zombie.touchDamage);
                zombie.lastHitTime = now;
            }
            zombie.velocityX *= 0.1;
        }

        applyCollisionSeparation(player, zombie) {
            if (player.x < zombie.x) {
                const push = (player.x + player.width) - zombie.x;
                player.x -= push * 0.2;
                zombie.x += push * 0.2;
            } else {
                const push = (zombie.x + zombie.width) - player.x;
                player.x += push * 0.2;
                zombie.x -= push * 0.2;
            }
        }
    }

    // =====================================================
    // ENTITY FACTORY
    // =====================================================
    class EntityFactory {
        static createPlayer() {
            return {
                x: CONFIG.PLAYER_START_X,
                y: 0,
                width: CONFIG.PLAYER_WIDTH,
                height: CONFIG.PLAYER_HEIGHT,
                velocityX: 0,
                velocityY: 0,
                hp: CONFIG.PLAYER_MAX_HP,
                maxHP: CONFIG.PLAYER_MAX_HP,
                onGround: true,
                facingRight: true
            };
        }

        static createZombie(x, type) {
            const template = ENEMY_TYPES[type];
            if (!template) return null;

            const zombie = {
                x: x,
                y: 0,
                width: template.width,
                height: template.height,
                velocityX: 0,
                velocityY: 0,
                hp: template.maxHP,
                maxHP: template.maxHP,
                speed: template.speed,
                touchDamage: template.touchDamage,
                hitCooldown: template.hitCooldown,
                lastHitTime: -999,
                onGround: true,
                facingRight: false,
                spriteKey: template.spriteKey,
                stuckTimer: 0
            };

            // Add type-specific properties
            if (type === 'zombieSpitter') {
                Object.assign(zombie, {
                    attackRange: template.attackRange,
                    attackCooldown: template.attackCooldown,
                    lastAttackTime: -999,
                    projectileSpeed: template.projectileSpeed,
                    projectileDamage: template.projectileDamage
                });
            }

            if (type === 'zombieTank') {
                Object.assign(zombie, {
                    shieldHP: template.shieldHP,
                    maxShieldHP: template.maxShieldHP
                });
            }

            return zombie;
        }
    }

    // =====================================================
    // MAIN GAME CLASS
    // =====================================================
    class ZombieSurvivalGame {
        constructor() {
            this.canvas = document.getElementById('gameCanvas');
            this.ctx = this.canvas.getContext('2d');
            this.ctx.imageSmoothingEnabled = false;
            
            this.initializeSystems();
            this.initializeGameState();
            this.setupCanvas();
            this.initializeSprites();
            
            this.lastTime = 0;
            this.deltaTime = 0;
            this.timeElapsed = 0;
            
            setTimeout(() => this.setupInitialPositions(), CONFIG.INITIAL_SETUP_DELAY);
            setTimeout(() => this.hideLoadingScreen(), CONFIG.LOADING_HIDE_DELAY);
        }

        initializeSystems() {
            this.audioManager = new AudioManager();
            this.inputManager = new InputManager(this);
            this.weaponSystem = new WeaponSystem(this);
            this.shopSystem = new ShopSystem(this);
            this.waveSystem = new WaveSystem(this);
            this.effectsManager = new EffectsManager(this);
            this.renderer = new Renderer(this);
            this.physics = new PhysicsEngine(this);
        }

        initializeGameState() {
            this.player = EntityFactory.createPlayer();
            this.gameOver = false;
            this.canRestart = false;
            this.bullets = [];
            this.zombies = [];
            this.acidProjectiles = [];
        }

        initializeSprites() {
            // Generate mirrored sprites
            const spritesToFlip = ['player', 'zombie', 'zombieFat', 'zombieSpitter', 
                                  'zombieTank', 'zombieTankUnshielded', 'merchant'];
            
            spritesToFlip.forEach(spriteName => {
                if (SPRITES[spriteName] && SPRITES[spriteName].left) {
                    SPRITES[spriteName].right = Utils.flipSprite(SPRITES[spriteName].left);
                }
            });
        }

        setupCanvas() {
            this.resizeCanvas();
            window.addEventListener('resize', () => this.resizeCanvas());
        }

        resizeCanvas() {
            const oldWidth = this.canvas.width;

            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;

            if (this.player && this.canvas.width < oldWidth) {
                this.player.x = Math.min(this.player.x, this.canvas.width - 100);
            }

            if (this.zombies) {
                this.zombies.forEach(zombie => {
                    if (zombie.x + zombie.width > this.canvas.width) {
                        zombie.x = this.canvas.width - zombie.width - 10;
                    }
                });
            }

            this.updatePositionsAfterResize();
        }

        updatePositionsAfterResize() {
            if (this.player) {
                const groundY = Utils.getGroundY(this.canvas.height, this.player.height);
                if (this.player.onGround) {
                    this.player.y = groundY;
                }
            }

            if (this.shopSystem) {
                const groundY = Utils.getGroundY(this.canvas.height, this.shopSystem.merchant.height);
                this.shopSystem.setMerchantPosition(groundY);
            }
        }

        setupInitialPositions() {
            if (this.canvas.width === 0 || this.canvas.height === 0) {
                setTimeout(() => this.setupInitialPositions(), 100);
                return;
            }
            
            this.player.x = Math.min(CONFIG.PLAYER_START_X, this.canvas.width - 200);
            
            const groundY = Utils.getGroundY(this.canvas.height, this.player.height);
            this.player.y = groundY;
            this.player.onGround = true;
            this.player.velocityY = 0;
            this.player.velocityX = 0;

            this.inputManager.mouse.x = this.player.x + this.player.width / 2;
            this.inputManager.mouse.y = this.player.y + this.player.height / 2;

            this.shopSystem.merchant.x = CONFIG.MERCHANT_X;
            this.shopSystem.setMerchantPosition(groundY);
        }

        hideLoadingScreen() {
            document.getElementById('loadingScreen').classList.add('hidden');
        }

        spawnZombie(x, type = 'zombie') {
            const zombie = EntityFactory.createZombie(x, type);
            if (zombie) {
                zombie.y = Utils.getGroundY(this.canvas.height, zombie.height);
                this.zombies.push(zombie);
            }
        }

        applyDamage(amount) {
            if (this.gameOver) return;
            
            this.player.hp = Math.max(0, this.player.hp - Math.floor(amount));
            this.effectsManager.addScreenShake(6);
            
            if (this.player.hp <= 0) {
                this.triggerGameOver();
            }
        }

        damageZombie(zombie, damage) {
            // Handle Tank zombie shield
            if (zombie.shieldHP !== undefined && zombie.shieldHP > 0) {
                zombie.shieldHP = Math.max(0, zombie.shieldHP - damage);
                
                if (zombie.shieldHP <= 0) {
                    this.effectsManager.createHitEffect(
                        zombie.x + zombie.width / 2, 
                        zombie.y + zombie.height / 2, 
                        'shieldBreak'
                    );
                    zombie.spriteKey = 'zombieTankUnshielded';
                }
                return false;
            }
            
            // Apply damage to health
            zombie.hp = Math.max(0, zombie.hp - damage);
            return zombie.hp <= 0;
        }

        triggerGameOver() {
            this.gameOver = true;
            this.canRestart = false;
            setTimeout(() => {
                this.canRestart = true;
            }, CONFIG.RESTART_DELAY);
        }

        restart() {
            this.initializeGameState();
            this.weaponSystem.inventory = this.weaponSystem.initializeInventory();
            this.weaponSystem.currentSlot = 'secondary';
            this.waveSystem.reset();
            this.shopSystem.closeShop();
            this.setupInitialPositions();
        }

        update(deltaTime) {
            if (this.gameOver) return;

            this.physics.update(deltaTime);
            this.shopSystem.update();
            this.weaponSystem.update();
            this.weaponSystem.checkReloadProgress();
            this.effectsManager.update(deltaTime);
            this.waveSystem.checkWaveCompletion();
        }

        render() {
            this.renderer.render();
        }

        start() {
            this.lastTime = performance.now();
            this.gameLoop(this.lastTime);
        }

        gameLoop(currentTime) {
            this.deltaTime = Utils.clamp((currentTime - this.lastTime) / 1000, 0, 0.0167);
            this.timeElapsed += this.deltaTime;
            this.lastTime = currentTime;

            this.update(this.deltaTime);
            this.render();

            requestAnimationFrame((time) => this.gameLoop(time));
        }
    }

    // =====================================================
    // INITIALIZATION
    // =====================================================
    window.addEventListener('DOMContentLoaded', () => {
        const game = new ZombieSurvivalGame();
        game.start();
        
        console.log(`%cZombie Survival Alpha v${CONFIG.GAME_VERSION}`, 'color: #7CFC00; font-size: 16px; font-weight: bold;');
        console.log('%cControls: WASD to move, 1-2-3 to switch weapons, Mouse to aim/shoot, E near merchant to open shop', 'color: #9cf;');
    });
    </script>
</body>
</html>
